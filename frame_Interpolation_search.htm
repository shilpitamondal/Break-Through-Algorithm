<!DOCTYPE html>
<html>
    <head>

    </head>
    <body>
        <h1>Interpolation Search</h1>
        <pre>
            The interpolation search is basically an improved version of the binary search. This searching algorithm resembles the method by which 
             one might search a telephone book for a name: with each step, the algorithm calculates where in the remaining search space the target 
             element might be based on the value of the bounds compared to the target element. If elements are uniformly distributed, the time 
             complexity is O(log (log n)). In worst cases it can take up to O(n).
          <h3>Algorithm:</h3> 
          Rest of the Interpolation algorithm is the same except the above partition logic. 
          Step1: In a loop, calculate the value of “pos” using the probe position formula. 
          Step2: If it is a match, return the index of the item, and exit. 
          Step3: If the item is less than arr[pos], calculate the probe position of the left sub-array. Otherwise calculate the same in the right sub-array. 
          Step4: Repeat until a match is found or the sub-array reduces to zero.
          Below is the implementation of algorithm. 
        </pre>
        <img src="images/interpolation.png">
        <pre>
            <h3>Corresponding code</h3>
                
            #include <stdio.h>
                // Part of Cosmos by OpenGenus Foundation
                int interpolationSearch(int* array, int n, int key){
                    int high = n-1;
                    int low = 0;
                    int mid;
                    while ( (array[high] != array[low]) && (key >= array[low]) && (key <= array[high])) {
                        mid = low + (int)( ((float)(high-low) / (array[high] - array[low])) * (key - array[low]) );
                        if(array[mid] == key)
                            return mid;
                        else if (array[mid] < key)
                            low = mid + 1;
                        else
                            high = mid - 1;
                    }
                    return -1;
                }
                void test(){
                    // Array of items on which search will be conducted.
                    int array[10] = {1, 5, 9, 12, 16, 18, 25, 56, 76, 78};
                    int n = sizeof(array)/sizeof(array[0]);
                    // Element to be searched
                    int key = 25;
                    int index = interpolationSearch(array, n, key);
                    if(index !=-1)
                        printf("Element found at index %d\n", index);
                    else
                        printf("EElement not found.\n");
                }
                int main() {
                    test(25);
                    return 0;
                }
            
            <h3>complexity:-</h3>
            case time complexity: O(N)
            Average case time complexity: O(log log N)
            Best case time complexity: O(1)
            Space complexity: O(1)
        On assuming a uniform distribution of the data on the linear scale used for interpolation, the performance can be shown to be O(log log n).
        Dynamic Interpolation Search is possible in o(log log n) time using a novel data structure.
       </pre>
    </body>

</html>